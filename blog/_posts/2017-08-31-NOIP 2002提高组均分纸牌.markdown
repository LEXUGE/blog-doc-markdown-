---
layout: post
title:  "NOIP 2002提高组均分纸牌"
tags: [编程,算法,OI]
date:   2017-08-31 09:18
categories: jekyll update
issueid: 17
---
> NOIP2002提高组均分纸牌题解分析  

1. 题目：  
- 题目描述 Description  
&#160; &#160; &#160; &#160;有 N 堆纸牌，编号分别为 1，2，…, N。每堆上有若干张，但纸牌总数必为 N 的倍数。可以在任一堆上取若于张纸牌，然后移动。  
&#160; &#160; &#160; &#160;移牌规则为：在编号为 1 堆上取的纸牌，只能移到编号为 2 的堆上；在编号为 N 的堆上取的纸牌，只能移到编号为 N-1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。  
&#160; &#160; &#160; &#160;现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。  
&#160; &#160; &#160; &#160;例如 N=4，4 堆纸牌数分别为：  
&#160; &#160; &#160; &#160;①　9　②　8　③　17　④　6  
&#160; &#160; &#160; &#160;移动3次可达到目的：  
&#160; &#160; &#160; &#160;从 ③ 取 4 张牌放到 ④ （9 8 13 10） -> 从 ③ 取 3 张牌放到 ②（9 11 10 10）-> 从 ② 取 1 张牌放到①（10 10 10 10）。  
- 输入描述 Input Description  
&#160; &#160; &#160; &#160;第一行N（N 堆纸牌，1 <= N <= 100）  
&#160; &#160; &#160; &#160;第二行A1 A2 … An （N 堆纸牌，每堆纸牌初始数，l<= Ai <=10000）  
- 输出描述 Output Description
&#160; &#160; &#160; &#160;输出至屏幕。格式为：  
&#160; &#160; &#160; &#160;所有堆均达到相等时的最少移动次数。  
- 样例输入 Sample Input  
&#160; &#160; &#160; &#160;4  
&#160; &#160; &#160; &#160;9 8 17 6  
- 样例输出 Sample Output  
&#160; &#160; &#160; &#160;3  
<br>
<br>
2. 思路与想法：  
本题是一道贪心题，一开始看可能不会有太明显的解法出现。  
先来看贪心的描述：
贪心法，又称贪心算法、贪婪算法、或称贪婪法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。  
所以是要用每一步的最优解来达到结果是最好或最优。这时候我就想到能否按照两个数一组，得到局部最优解后变为一个数，再与下一个数进行相同操作，形成递归。  
那么局部最优解是怎么产生的呢？我一开始想的是平均数，但实际上并不是这样。因为这道题我们可以保证纸牌数据是一定可以均分的，这样我们就不需要考虑移动的具体方案。  
所以我们先求出所有纸牌的平均数avg，然后计算出所有数据与avg之间存在的差值。对任意两个经过差值处理的数据a,b，存在以下情况：
- a<0且b<0  
- a<0且b>0  
- a>0且b<0  
- a>0且b>0  
- a=0且b!=0（包括了b>0和b<0两种情况）  
- a!=0且b=0（包括了a>0和a<0两种情况）  
<br>
<hr>
然后呢？我一开始想过进一步关于a+b进行分类，但其实完全不必要，这里篇幅有限，不再赘述。有兴趣可以自己想想如果考虑a+b，那么该如何进一步做题。  
对于除```a=0```以外的所有情况，我们都可以这样处理，将a,b相加（a移动到b），并对移动次数加1，这时候再与下一个数做处理。  
为什么要排除```a=0```？因为在a=0的时候不需要移动。那为什么```a!=0且b=0```时需要？因为是从左向右移动，a必须移动。  
最后，本题的解法就是：  
- 对所有数据转换为与平均数的差值。
- 在a=0且b!=0的情况下，移动次数加1。并无论什么情况，进行b=a+b的操作。之后以b作a,与下一个b进行相同处理
- 到递归结束时，移动次数就是解。

<br>
<hr>
C程序实现：  
```c
#include <stdio.h>

int a[101]={0},avg=0,t=0,n=0;

int solve(int p)
{
  if (p==n)
  {
    printf("%d\n",t);
    return 0;
  }
  if (a[p]!=0) t++;
  a[p+1]=a[p]+a[p+1];
  solve(p+1);
  return 0;
}

int main()
{
  int i=0,sum=0;
  scanf("%d", &n);
  for (i=1;i<=n;i++)
  {
    scanf("%d", &a[i]);
    sum+=a[i];
  }
  avg=sum/n;
  for (i=1;i<=n;i++)
    a[i]=a[i]-avg;
  solve(1);
  return 0;
}
```
